# Проблема: Мы можем иметь много подключений к серверу, много обращений для ожидания ответа, но сервер всегда будет занят одним процессом
# в связи с чем появляется необходимость организации какого-либо менеджера, который мог бы следить за процессом и присотанавливать программу,
# которая находится в ожидании, и давать возможность новому подключению, клиенту, итерации, выполнять желаемые действия, и продолжать выполнять
# приостановленную программу в случае получения ожидаемых данных.

import socket

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # создаём сокет, тип адресов ipv4, используем протокол TCP
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # настройка сокета, включаем перееиспользование, т.к. по стандарту сокет будет занят какое то время, чтобы идущие пакеты успели дойти
server_socket.bind(('localhost', 5000)) # привязываем сокет к хосту
server_socket.listen() # включаем сокет на прослушивание


while True: # сервер постоянно слушает вход
    client_socket, addr = server_socket.accept() # мы начинаем следить за приходящими подключениями, данный метод выдает кортеж входящих подключений, сокет и адрес, пока не получим входящее подключение, будем стоять. Это блокирующая функция.
    print('Connection from', addr)
    
    while True: # постоянно проверяем, получили мы что то, если нет, прерываем эту часть цикла, если получили запрос - выдаем ответ и дальше опять брейк.
        request = client_socket.recv(4096) # принемаем запрос пользователя, указываем буфер для сообщения - 4 кб
        
        if not request:
            break
        else:
            response = 'Hello World!\n'.encode() # если есть запрос, оттдаем ответ, всё передается в байтах, по этому кодируем в байты.
            client_socket.send(response) # ответ

# Мы можем решить эту задачу 3 способами.
# 1. Колбеки
# 2. Карутины и генераторы
# 3. asinc awiat
            
    
    